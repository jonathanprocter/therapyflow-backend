// =============================================================================
// CLINICAL SECOND BRAIN - INTELLIGENT RECALL & LINKING SYSTEM
// Core functionality for contextual memory, pattern recognition, and therapeutic insights
// =============================================================================

// =============================================================================
// 1. KNOWLEDGE GRAPH BUILDER
// File: src/services/knowledgeGraph.ts
// =============================================================================

import { db } from '../db';
import { progressNotes, clients, therapeuticGoals, interventions, clientConnections } from '../db/schema';
import { ClinicalSemanticSearch } from './semanticSearch';
import { eq, and, sql, desc, asc } from 'drizzle-orm';

export interface ClinicalEntity {
  id: string;
  type: 'client' | 'goal' | 'intervention' | 'theme' | 'pattern' | 'outcome';
  name: string;
  metadata: Record<string, any>;
  connections: ClinicalConnection[];
}

export interface ClinicalConnection {
  fromEntityId: string;
  toEntityId: string;
  relationshipType: 'relates_to' | 'caused_by' | 'leads_to' | 'similar_to' | 'part_of' | 'contradicts';
  strength: number; // 0-1 confidence score
  evidence: string[]; // Session notes that support this connection
  firstObserved: Date;
  lastReinforced: Date;
  frequency: number; // How often this connection appears
}

/**
 * Clinical Knowledge Graph Builder
 * Creates intelligent connections between all elements of a client's therapeutic journey
 */
export class ClinicalKnowledgeGraph {
  private semanticSearch: ClinicalSemanticSearch;

  constructor() {
    this.semanticSearch = new ClinicalSemanticSearch();
  }

  /**
   * Build comprehensive knowledge graph for a client
   * This is the core "second brain" intelligence
   */
  async buildClientKnowledgeGraph(clientId: string, practitionerId: string): Promise<{
    entities: ClinicalEntity[];
    connections: ClinicalConnection[];
    insights: string[];
    therapeuticJourney: TherapeuticJourney;
  }> {
    console.log(`[KNOWLEDGE GRAPH] Building for client ${clientId}`);

    // 1. Extract all entities from client's history
    const entities = await this.extractClinicalEntities(clientId, practitionerId);

    // 2. Discover connections between entities
    const connections = await this.discoverConnections(entities, clientId, practitionerId);

    // 3. Generate insights from the graph
    const insights = await this.generateGraphInsights(entities, connections);

    // 4. Map the therapeutic journey
    const therapeuticJourney = await this.mapTherapeuticJourney(clientId, practitionerId, entities, connections);

    return {
      entities,
      connections,
      insights,
      therapeuticJourney,
    };
  }

  /**
   * Extract all clinical entities from client's history
   */
  private async extractClinicalEntities(clientId: string, practitionerId: string): Promise<ClinicalEntity[]> {
    const entities: ClinicalEntity[] = [];

    // Get all progress notes
    const notes = await db
      .select()
      .from(progressNotes)
      .where(eq(progressNotes.clientId, clientId))
      .orderBy(asc(progressNotes.sessionDate));

    // Extract themes, goals, interventions from each note
    for (const note of notes) {
      const noteEntities = await this.extractEntitiesFromNote(note);
      entities.push(...noteEntities);
    }

    // Deduplicate and merge similar entities
    return this.consolidateEntities(entities);
  }

  /**
   * Extract entities from a single progress note using NLP and AI
   */
  private async extractEntitiesFromNote(note: any): Promise<ClinicalEntity[]> {
    const entities: ClinicalEntity[] = [];
    const content = note.content; // Assume already decrypted

    // 1. Extract therapeutic themes using semantic analysis
    const themes = await this.extractThemes(content, note.sessionDate);
    entities.push(...themes);

    // 2. Extract mentioned goals and objectives
    const goals = await this.extractGoals(content, note.sessionDate);
    entities.push(...goals);

    // 3. Extract interventions and techniques used
    const interventions = await this.extractInterventions(content, note.sessionDate);
    entities.push(...interventions);

    // 4. Extract emotional patterns and mood indicators
    const emotions = await this.extractEmotionalPatterns(content, note.sessionDate);
    entities.push(...emotions);

    // 5. Extract behavioral patterns
    const behaviors = await this.extractBehavioralPatterns(content, note.sessionDate);
    entities.push(...behaviors);

    return entities;
  }

  /**
   * Discover connections between entities using semantic similarity and temporal patterns
   */
  private async discoverConnections(
    entities: ClinicalEntity[],
    clientId: string,
    practitionerId: string
  ): Promise<ClinicalConnection[]> {
    const connections: ClinicalConnection[] = [];

    // 1. Semantic similarity connections
    const semanticConnections = await this.findSemanticConnections(entities);
    connections.push(...semanticConnections);

    // 2. Temporal sequence connections (what leads to what)
    const temporalConnections = await this.findTemporalConnections(entities);
    connections.push(...temporalConnections);

    // 3. Causal relationship connections
    const causalConnections = await this.findCausalConnections(entities, clientId);
    connections.push(...causalConnections);

    // 4. Contradictory pattern connections
    const contradictoryConnections = await this.findContradictoryPatterns(entities);
    connections.push(...contradictoryConnections);

    return this.consolidateConnections(connections);
  }

  /**
   * Find entities that are semantically related
   */
  private async findSemanticConnections(entities: ClinicalEntity[]): Promise<ClinicalConnection[]> {
    const connections: ClinicalConnection[] = [];

    for (let i = 0; i < entities.length; i++) {
      for (let j = i + 1; j < entities.length; j++) {
        const entityA = entities[i];
        const entityB = entities[j];

        // Use semantic similarity to determine connection strength
        const similarity = await this.calculateSemanticSimilarity(entityA.name, entityB.name);

        if (similarity > 0.7) { // High similarity threshold
          connections.push({
            fromEntityId: entityA.id,
            toEntityId: entityB.id,
            relationshipType: 'relates_to',
            strength: similarity,
            evidence: [
              `Semantic similarity: ${Math.round(similarity * 100)}%`,
              `Both appear in similar therapeutic contexts`
            ],
            firstObserved: new Date(Math.min(
              new Date(entityA.metadata.firstSeen).getTime(),
              new Date(entityB.metadata.firstSeen).getTime()
            )),
            lastReinforced: new Date(),
            frequency: 1,
          });
        }
      }
    }

    return connections;
  }

  /**
   * Find temporal patterns - what comes before/after what
   */
  private async findTemporalConnections(entities: ClinicalEntity[]): Promise<ClinicalConnection[]> {
    const connections: ClinicalConnection[] = [];

    // Sort entities by first appearance
    const sortedEntities = entities.sort((a, b) => 
      new Date(a.metadata.firstSeen).getTime() - new Date(b.metadata.firstSeen).getTime()
    );

    // Look for entities that consistently appear in sequence
    for (let i = 0; i < sortedEntities.length - 1; i++) {
      const current = sortedEntities[i];
      const next = sortedEntities[i + 1];

      // Check if there's a consistent temporal pattern
      const timeDiff = new Date(next.metadata.firstSeen).getTime() - new Date(current.metadata.firstSeen).getTime();
      const sessionDiff = Math.abs(timeDiff / (1000 * 60 * 60 * 24 * 7)); // Difference in weeks

      // If entities appear within a reasonable therapeutic timeframe
      if (sessionDiff <= 4) { // Within 4 weeks
        const strength = this.calculateTemporalStrength(current, next);
        
        if (strength > 0.6) {
          connections.push({
            fromEntityId: current.id,
            toEntityId: next.id,
            relationshipType: 'leads_to',
            strength,
            evidence: [
              `${current.name} consistently appeared before ${next.name}`,
              `Temporal gap: ${Math.round(sessionDiff)} weeks`
            ],
            firstObserved: new Date(current.metadata.firstSeen),
            lastReinforced: new Date(),
            frequency: 1,
          });
        }
      }
    }

    return connections;
  }

  /**
   * Generate insights from the knowledge graph
   */
  private async generateGraphInsights(
    entities: ClinicalEntity[],
    connections: ClinicalConnection[]
  ): Promise<string[]> {
    const insights: string[] = [];

    // 1. Most connected themes (central to client's experience)
    const connectionCounts = this.countEntityConnections(entities, connections);
    const mostConnected = Object.entries(connectionCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3);

    if (mostConnected.length > 0) {
      const [entityId, count] = mostConnected[0];
      const entity = entities.find(e => e.id === entityId);
      if (entity) {
        insights.push(`"${entity.name}" is central to this client's therapeutic experience (${count} connections)`);
      }
    }

    // 2. Strong causal patterns
    const causalConnections = connections.filter(c => c.relationshipType === 'leads_to' && c.strength > 0.8);
    if (causalConnections.length > 0) {
      const strongest = causalConnections[0];
      const fromEntity = entities.find(e => e.id === strongest.fromEntityId);
      const toEntity = entities.find(e => e.id === strongest.toEntityId);
      
      if (fromEntity && toEntity) {
        insights.push(`Strong pattern: "${fromEntity.name}" consistently leads to "${toEntity.name}"`);
      }
    }

    // 3. Contradictory patterns that need attention
    const contradictions = connections.filter(c => c.relationshipType === 'contradicts');
    if (contradictions.length > 0) {
      insights.push(`Found ${contradictions.length} contradictory patterns that may need therapeutic attention`);
    }

    // 4. Therapeutic progress indicators
    const progressEntities = entities.filter(e => 
      e.name.toLowerCase().includes('progress') || 
      e.name.toLowerCase().includes('improvement') ||
      e.metadata.sentiment === 'positive'
    );

    if (progressEntities.length > 0) {
      insights.push(`${progressEntities.length} positive progress indicators identified across sessions`);
    }

    // 5. Recurring themes that might need deeper exploration
    const recurringThemes = entities.filter(e => e.metadata.frequency > 3);
    if (recurringThemes.length > 0) {
      const themeNames = recurringThemes.map(t => t.name).join(', ');
      insights.push(`Recurring themes requiring continued attention: ${themeNames}`);
    }

    return insights;
  }

  // Helper methods for entity extraction
  private async extractThemes(content: string, sessionDate: Date): Promise<ClinicalEntity[]> {
    // Use NLP to extract therapeutic themes
    const themes: string[] = [];
    
    // Pattern matching for common therapeutic themes
    const themePatterns = {
      'anxiety': /\b(anxious|anxiety|worried|nervous|panic|fear)\b/gi,
      'depression': /\b(depressed|depression|sad|hopeless|down|low mood)\b/gi,
      'relationships': /\b(relationship|partner|family|friends|social|marriage)\b/gi,
      'work stress': /\b(work|job|career|workplace|boss|colleague|stress)\b/gi,
      'self-esteem': /\b(self-esteem|confidence|self-worth|self-image|insecure)\b/gi,
      'trauma': /\b(trauma|traumatic|abuse|assault|accident|loss)\b/gi,
      'coping': /\b(coping|cope|manage|handle|deal with|strategy)\b/gi,
      'goals': /\b(goal|objective|target|aim|want to|hoping to)\b/gi,
    };

    for (const [theme, pattern] of Object.entries(themePatterns)) {
      if (pattern.test(content)) {
        themes.push(theme);
      }
    }

    return themes.map(theme => ({
      id: `theme-${theme}-${sessionDate.getTime()}`,
      type: 'theme' as const,
      name: theme,
      metadata: {
        firstSeen: sessionDate,
        sessionDate,
        frequency: 1,
        context: this.extractContext(content, theme),
      },
      connections: [],
    }));
  }

  private async extractGoals(content: string, sessionDate: Date): Promise<ClinicalEntity[]> {
    const goals: ClinicalEntity[] = [];
    
    // Pattern matching for goals and objectives
    const goalPatterns = [
      /I want to (.+?)(?:\.|$)/gi,
      /My goal is to (.+?)(?:\.|$)/gi,
      /I hope to (.+?)(?:\.|$)/gi,
      /I would like to (.+?)(?:\.|$)/gi,
      /I need to (.+?)(?:\.|$)/gi,
    ];

    for (const pattern of goalPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const goalText = match[1].trim();
        if (goalText.length > 5 && goalText.length < 100) {
          goals.push({
            id: `goal-${Date.now()}-${Math.random()}`,
            type: 'goal',
            name: goalText,
            metadata: {
              firstSeen: sessionDate,
              sessionDate,
              frequency: 1,
              category: this.categorizeGoal(goalText),
            },
            connections: [],
          });
        }
      }
    }

    return goals;
  }

  private async extractInterventions(content: string, sessionDate: Date): Promise<ClinicalEntity[]> {
    const interventions: ClinicalEntity[] = [];
    
    const interventionPatterns = {
      'cognitive restructuring': /\b(thought.*challenging|cognitive.*restructuring|reframe|thinking.*pattern)\b/gi,
      'mindfulness': /\b(mindful|meditation|breathing.*exercise|present.*moment)\b/gi,
      'exposure therapy': /\b(exposure|gradually.*face|confront.*fear)\b/gi,
      'behavioral activation': /\b(behavioral.*activation|activity.*scheduling|pleasant.*activit)\b/gi,
      'grounding techniques': /\b(grounding|five.*senses|grounding.*technique)\b/gi,
      'homework assignment': /\b(homework|assignment|practice|exercise.*between)\b/gi,
    };

    for (const [intervention, pattern] of Object.entries(interventionPatterns)) {
      if (pattern.test(content)) {
        interventions.push({
          id: `intervention-${intervention}-${sessionDate.getTime()}`,
          type: 'intervention',
          name: intervention,
          metadata: {
            firstSeen: sessionDate,
            sessionDate,
            frequency: 1,
            effectiveness: this.assessInterventionEffectiveness(content, intervention),
          },
          connections: [],
        });
      }
    }

    return interventions;
  }

  private async extractEmotionalPatterns(content: string, sessionDate: Date): Promise<ClinicalEntity[]> {
    const emotions: ClinicalEntity[] = [];
    
    const emotionPatterns = {
      'anger': /\b(angry|mad|furious|irritated|rage|frustrated)\b/gi,
      'sadness': /\b(sad|crying|tears|grief|sorrow|melancholy)\b/gi,
      'joy': /\b(happy|joyful|excited|elated|content|pleased)\b/gi,
      'fear': /\b(scared|afraid|terrified|fearful|worried|anxious)\b/gi,
      'shame': /\b(ashamed|guilty|embarrassed|humiliated|regret)\b/gi,
      'confusion': /\b(confused|uncertain|unclear|lost|overwhelmed)\b/gi,
    };

    for (const [emotion, pattern] of Object.entries(emotionPatterns)) {
      const matches = content.match(pattern);
      if (matches && matches.length > 0) {
        emotions.push({
          id: `emotion-${emotion}-${sessionDate.getTime()}`,
          type: 'pattern',
          name: `emotional pattern: ${emotion}`,
          metadata: {
            firstSeen: sessionDate,
            sessionDate,
            frequency: matches.length,
            intensity: this.assessEmotionalIntensity(content, emotion),
            sentiment: this.classifyEmotionSentiment(emotion),
          },
          connections: [],
        });
      }
    }

    return emotions;
  }

  private async extractBehavioralPatterns(content: string, sessionDate: Date): Promise<ClinicalEntity[]> {
    const behaviors: ClinicalEntity[] = [];
    
    const behaviorPatterns = {
      'avoidance': /\b(avoid|avoiding|stayed away|didn\'t go|cancelled)\b/gi,
      'isolation': /\b(isolated|alone|withdrew|hiding|stayed home)\b/gi,
      'self-care': /\b(exercise|healthy eating|sleep|shower|grooming)\b/gi,
      'social connection': /\b(called.*friend|social|party|gathering|visited)\b/gi,
      'procrastination': /\b(procrastinat|put off|delayed|postponed)\b/gi,
      'achievement': /\b(accomplished|achieved|completed|finished|success)\b/gi,
    };

    for (const [behavior, pattern] of Object.entries(behaviorPatterns)) {
      if (pattern.test(content)) {
        behaviors.push({
          id: `behavior-${behavior}-${sessionDate.getTime()}`,
          type: 'pattern',
          name: `behavioral pattern: ${behavior}`,
          metadata: {
            firstSeen: sessionDate,
            sessionDate,
            frequency: 1,
            category: this.categorizeBehavior(behavior),
            impact: this.assessBehavioralImpact(content, behavior),
          },
          connections: [],
        });
      }
    }

    return behaviors;
  }

  // Helper methods for analysis
  private extractContext(content: string, theme: string): string {
    const sentences = content.split(/[.!?]+/);
    const relevantSentences = sentences.filter(sentence => 
      sentence.toLowerCase().includes(theme.toLowerCase())
    );
    return relevantSentences.slice(0, 2).join('. ').trim();
  }

  private categorizeGoal(goalText: string): string {
    const categories = {
      'emotional': /\b(feel|emotion|mood|anxiety|depression|stress)\b/i,
      'behavioral': /\b(do|action|behavior|habit|routine|activity)\b/i,
      'social': /\b(relationship|social|friend|family|communicate)\b/i,
      'professional': /\b(work|job|career|professional|workplace)\b/i,
      'personal': /\b(self|personal|identity|confidence|growth)\b/i,
    };

    for (const [category, pattern] of Object.entries(categories)) {
      if (pattern.test(goalText)) {
        return category;
      }
    }
    return 'general';
  }

  private assessInterventionEffectiveness(content: string, intervention: string): number {
    // Look for positive language following intervention mentions
    const effectivenessIndicators = /\b(helpful|better|improved|working|effective|good|positive)\b/gi;
    const ineffectivenessIndicators = /\b(not.*help|worse|difficult|hard|ineffective|bad)\b/gi;
    
    const positiveMatches = content.match(effectivenessIndicators)?.length || 0;
    const negativeMatches = content.match(ineffectivenessIndicators)?.length || 0;
    
    const score = (positiveMatches - negativeMatches + 1) / 3; // Normalize to 0-1
    return Math.max(0, Math.min(1, score));
  }

  private assessEmotionalIntensity(content: string, emotion: string): number {
    const intensityWords = {
      'very': 0.8,
      'extremely': 1.0,
      'really': 0.7,
      'quite': 0.6,
      'somewhat': 0.4,
      'a little': 0.3,
      'slightly': 0.2,
    };

    for (const [intensifier, score] of Object.entries(intensityWords)) {
      if (content.toLowerCase().includes(`${intensifier} ${emotion}`)) {
        return score;
      }
    }
    return 0.5; // Default moderate intensity
  }

  private classifyEmotionSentiment(emotion: string): 'positive' | 'negative' | 'neutral' {
    const positiveEmotions = ['joy', 'happiness', 'excitement', 'contentment'];
    const negativeEmotions = ['anger', 'sadness', 'fear', 'shame', 'anxiety'];
    
    if (positiveEmotions.some(pos => emotion.includes(pos))) return 'positive';
    if (negativeEmotions.some(neg => emotion.includes(neg))) return 'negative';
    return 'neutral';
  }

  private categorizeBehavior(behavior: string): 'adaptive' | 'maladaptive' | 'neutral' {
    const adaptiveBehaviors = ['self-care', 'social connection', 'achievement', 'exercise'];
    const maladaptiveBehaviors = ['avoidance', 'isolation', 'procrastination'];
    
    if (adaptiveBehaviors.includes(behavior)) return 'adaptive';
    if (maladaptiveBehaviors.includes(behavior)) return 'maladaptive';
    return 'neutral';
  }

  private assessBehavioralImpact(content: string, behavior: string): 'positive' | 'negative' | 'neutral' {
    // Analyze the context around behavioral mentions
    const positiveContext = /\b(helped|better|good|positive|beneficial|improvement)\b/gi;
    const negativeContext = /\b(worse|bad|negative|harmful|difficult|problem)\b/gi;
    
    const positiveMatches = content.match(positiveContext)?.length || 0;
    const negativeMatches = content.match(negativeContext)?.length || 0;
    
    if (positiveMatches > negativeMatches) return 'positive';
    if (negativeMatches > positiveMatches) return 'negative';
    return 'neutral';
  }

  private async calculateSemanticSimilarity(text1: string, text2: string): Promise<number> {
    // This would use the semantic search service to calculate similarity
    // For now, using a simple keyword-based approach
    const words1 = new Set(text1.toLowerCase().split(/\s+/));
    const words2 = new Set(text2.toLowerCase().split(/\s+/));
    
    const intersection = new Set([...words1].filter(word => words2.has(word)));
    const union = new Set([...words1, ...words2]);
    
    return intersection.size / union.size; // Jaccard similarity
  }

  private calculateTemporalStrength(entityA: ClinicalEntity, entityB: ClinicalEntity): number {
    // Calculate how likely entityA leads to entityB based on temporal patterns
    // This is a simplified implementation - in production, you'd use more sophisticated analysis
    
    const timeDiff = new Date(entityB.metadata.firstSeen).getTime() - new Date(entityA.metadata.firstSeen).getTime();
    const daysDiff = timeDiff / (1000 * 60 * 60 * 24);
    
    // Optimal therapeutic interval is 1-14 days
    if (daysDiff >= 1 && daysDiff <= 14) {
      return 0.8;
    } else if (daysDiff <= 30) {
      return 0.6;
    } else {
      return 0.3;
    }
  }

  private async findCausalConnections(entities: ClinicalEntity[], clientId: string): Promise<ClinicalConnection[]> {
    // Implement causal inference based on therapeutic knowledge and patterns
    // This would be a sophisticated ML model in production
    return [];
  }

  private async findContradictoryPatterns(entities: ClinicalEntity[]): Promise<ClinicalConnection[]> {
    // Find entities that represent contradictory patterns
    const connections: ClinicalConnection[] = [];
    
    // Look for opposing emotional patterns
    const emotions = entities.filter(e => e.type === 'pattern' && e.name.includes('emotional pattern'));
    
    for (let i = 0; i < emotions.length; i++) {
      for (let j = i + 1; j < emotions.length; j++) {
        const emotionA = emotions[i];
        const emotionB = emotions[j];
        
        if (this.areOpposingEmotions(emotionA.name, emotionB.name)) {
          connections.push({
            fromEntityId: emotionA.id,
            toEntityId: emotionB.id,
            relationshipType: 'contradicts',
            strength: 0.8,
            evidence: ['Opposing emotional patterns detected'],
            firstObserved: new Date(Math.min(
              new Date(emotionA.metadata.firstSeen).getTime(),
              new Date(emotionB.metadata.firstSeen).getTime()
            )),
            lastReinforced: new Date(),
            frequency: 1,
          });
        }
      }
    }
    
    return connections;
  }

  private areOpposingEmotions(emotionA: string, emotionB: string): boolean {
    const opposites = [
      ['joy', 'sadness'],
      ['anger', 'contentment'],
      ['fear', 'confidence'],
      ['shame', 'pride'],
    ];
    
    return opposites.some(([a, b]) => 
      (emotionA.includes(a) && emotionB.includes(b)) ||
      (emotionA.includes(b) && emotionB.includes(a))
    );
  }

  private consolidateEntities(entities: ClinicalEntity[]): ClinicalEntity[] {
    // Merge similar entities and update frequency counts
    const consolidated = new Map<string, ClinicalEntity>();
    
    for (const entity of entities) {
      const key = `${entity.type}-${entity.name}`;
      
      if (consolidated.has(key)) {
        const existing = consolidated.get(key)!;
        existing.metadata.frequency = (existing.metadata.frequency || 1) + 1;
        existing.metadata.lastSeen = entity.metadata.sessionDate;
      } else {
        consolidated.set(key, { ...entity, metadata: { ...entity.metadata, frequency: 1 } });
      }
    }
    
    return Array.from(consolidated.values());
  }

  private consolidateConnections(connections: ClinicalConnection[]): ClinicalConnection[] {
    // Merge duplicate connections and strengthen them
    const consolidated = new Map<string, ClinicalConnection>();
    
    for (const connection of connections) {
      const key = `${connection.fromEntityId}-${connection.toEntityId}-${connection.relationshipType}`;
      
      if (consolidated.has(key)) {
        const existing = consolidated.get(key)!;
        existing.frequency += 1;
        existing.strength = Math.min(1, existing.strength + 0.1); // Strengthen with evidence
        existing.lastReinforced = new Date();
      } else {
        consolidated.set(key, connection);
      }
    }
    
    return Array.from(consolidated.values());
  }

  private countEntityConnections(entities: ClinicalEntity[], connections: ClinicalConnection[]): Record<string, number> {
    const counts: Record<string, number> = {};
    
    for (const entity of entities) {
      counts[entity.id] = connections.filter(c => 
        c.fromEntityId === entity.id || c.toEntityId === entity.id
      ).length;
    }
    
    return counts;
  }

  private async mapTherapeuticJourney(
    clientId: string,
    practitionerId: string,
    entities: ClinicalEntity[],
    connections: ClinicalConnection[]
  ): Promise<TherapeuticJourney> {
    // Map the complete therapeutic journey with timeline and progress indicators
    const goals = entities.filter(e => e.type === 'goal');
    const themes = entities.filter(e => e.type === 'theme');
    const interventions = entities.filter(e => e.type === 'intervention');
    
    return {
      startDate: new Date(Math.min(...entities.map(e => new Date(e.metadata.firstSeen).getTime()))),
      currentDate: new Date(),
      phases: await this.identifyTherapeuticPhases(entities, connections),
      progressIndicators: await this.calculateProgressIndicators(entities, connections),
      keyMilestones: await this.identifyKeyMilestones(entities, connections),
      therapeuticGoals: goals,
      centralThemes: themes.slice(0, 5), // Top 5 themes
      effectiveInterventions: interventions.filter(i => i.metadata.effectiveness > 0.7),
    };
  }

  private async identifyTherapeuticPhases(entities: ClinicalEntity[], connections: ClinicalConnection[]): Promise<TherapeuticPhase[]> {
    // Identify distinct phases of therapy based on entity clusters and timeline
    return []; // Implementation would analyze temporal clusters
  }

  private async calculateProgressIndicators(entities: ClinicalEntity[], connections: ClinicalConnection[]): Promise<ProgressIndicator[]> {
    // Calculate various progress metrics
    return []; // Implementation would analyze positive trend indicators
  }

  private async identifyKeyMilestones(entities: ClinicalEntity[], connections: ClinicalConnection[]): Promise<Milestone[]> {
    // Identify significant moments in the therapeutic journey
    return []; // Implementation would find breakthrough moments
  }
}

// =============================================================================
// 2. PROACTIVE INSIGHT ENGINE
// File: src/services/insightEngine.ts
// =============================================================================

export interface ProactiveInsight {
  type: 'connection' | 'pattern' | 'suggestion' | 'alert' | 'milestone';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  title: string;
  description: string;
  evidence: string[];
  relevantNotes: string[];
  suggestedActions: string[];
  confidence: number;
  generatedAt: Date;
}

export interface TherapeuticJourney {
  startDate: Date;
  currentDate: Date;
  phases: TherapeuticPhase[];
  progressIndicators: ProgressIndicator[];
  keyMilestones: Milestone[];
  therapeuticGoals: ClinicalEntity[];
  centralThemes: ClinicalEntity[];
  effectiveInterventions: ClinicalEntity[];
}

export interface TherapeuticPhase {
  id: string;
  name: string;
  startDate: Date;
  endDate?: Date;
  focus: string[];
  outcomes: string[];
  dominantThemes: string[];
}

export interface ProgressIndicator {
  metric: string;
  trend: 'improving' | 'stable' | 'declining';
  confidence: number;
  evidence: string[];
  timeframe: { start: Date; end: Date };
}

export interface Milestone {
  date: Date;
  description: string;
  significance: 'breakthrough' | 'setback' | 'goal_achieved' | 'insight';
  relatedEntities: string[];
}

/**
 * Proactive Insight Engine
 * Continuously analyzes patterns and surfaces relevant insights without being asked
 */
export class ProactiveInsightEngine {
  private knowledgeGraph: ClinicalKnowledgeGraph;

  constructor() {
    this.knowledgeGraph = new ClinicalKnowledgeGraph();
  }

  /**
   * Generate proactive insights for the current session
   * This is called whenever a user opens a client's file or adds a new note
   */
  async generateInsightsForSession(
    clientId: string,
    practitionerId: string,
    currentContext?: {
      recentNotes?: string[];
      plannedTopics?: string[];
      lastSessionSummary?: string;
    }
  ): Promise<{
    insights: ProactiveInsight[];
    relevantHistory: Array<{
      noteId: string;
      content: string;
      relevanceScore: number;
      reason: string;
    }>;
    suggestedQuestions: string[];
    therapeuticOpportunities: string[];
  }> {
    console.log(`[INSIGHT ENGINE] Generating proactive insights for client ${clientId}`);

    // 1. Build current knowledge graph
    const graph = await this.knowledgeGraph.buildClientKnowledgeGraph(clientId, practitionerId);

    // 2. Generate proactive insights
    const insights = await this.generateProactiveInsights(graph, currentContext);

    // 3. Find relevant historical context
    const relevantHistory = await this.findRelevantHistory(clientId, practitionerId, currentContext);

    // 4. Generate suggested questions for the session
    const suggestedQuestions = await this.generateSuggestedQuestions(graph, currentContext);

    // 5. Identify therapeutic opportunities
    const therapeuticOpportunities = await this.identifyTherapeuticOpportunities(graph);

    return {
      insights,
      relevantHistory,
      suggestedQuestions,
      therapeuticOpportunities,
    };
  }

  /**
   * Generate specific proactive insights based on patterns
   */
  private async generateProactiveInsights(
    graph: {
      entities: ClinicalEntity[];
      connections: ClinicalConnection[];
      insights: string[];
      therapeuticJourney: TherapeuticJourney;
    },
    context?: any
  ): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    // 1. Pattern Recognition Insights
    insights.push(...await this.generatePatternInsights(graph));

    // 2. Progress Tracking Insights
    insights.push(...await this.generateProgressInsights(graph));

    // 3. Goal Alignment Insights
    insights.push(...await this.generateGoalAlignmentInsights(graph));

    // 4. Intervention Effectiveness Insights
    insights.push(...await this.generateInterventionInsights(graph));

    // 5. Risk Detection Insights
    insights.push(...await this.generateRiskInsights(graph));

    // 6. Opportunity Recognition Insights
    insights.push(...await this.generateOpportunityInsights(graph));

    // Sort by priority and confidence
    return insights.sort((a, b) => {
      const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return b.confidence - a.confidence;
    });
  }

  private async generatePatternInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    // Look for recurring negative patterns
    const negativePatterns = graph.entities.filter(e => 
      e.type === 'pattern' && 
      e.metadata.frequency > 2 && 
      (e.metadata.sentiment === 'negative' || e.metadata.category === 'maladaptive')
    );

    for (const pattern of negativePatterns) {
      insights.push({
        type: 'pattern',
        priority: 'medium',
        title: `Recurring Pattern: ${pattern.name}`,
        description: `This pattern has appeared ${pattern.metadata.frequency} times. Consider addressing the underlying triggers or developing specific coping strategies.`,
        evidence: [`Frequency: ${pattern.metadata.frequency} occurrences`, `First observed: ${pattern.metadata.firstSeen}`],
        relevantNotes: [], // Would be populated with specific note IDs
        suggestedActions: [
          'Explore triggers for this pattern',
          'Develop specific intervention for this behavior',
          'Track pattern frequency between sessions'
        ],
        confidence: 0.8,
        generatedAt: new Date(),
      });
    }

    // Look for positive patterns that could be reinforced
    const positivePatterns = graph.entities.filter(e => 
      e.type === 'pattern' && 
      e.metadata.sentiment === 'positive' && 
      e.metadata.frequency > 1
    );

    for (const pattern of positivePatterns) {
      insights.push({
        type: 'pattern',
        priority: 'low',
        title: `Positive Pattern: ${pattern.name}`,
        description: `This positive pattern is emerging. Consider reinforcing and expanding on this progress.`,
        evidence: [`Frequency: ${pattern.metadata.frequency} occurrences`],
        relevantNotes: [],
        suggestedActions: [
          'Reinforce this positive behavior',
          'Explore how to generalize this success',
          'Celebrate this progress with the client'
        ],
        confidence: 0.7,
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  private async generateProgressInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    // Analyze progress indicators from the therapeutic journey
    const progressIndicators = graph.therapeuticJourney.progressIndicators;

    for (const indicator of progressIndicators) {
      if (indicator.trend === 'improving' && indicator.confidence > 0.7) {
        insights.push({
          type: 'milestone',
          priority: 'medium',
          title: `Progress Detected: ${indicator.metric}`,
          description: `Significant improvement observed in ${indicator.metric}. This progress could be highlighted and reinforced.`,
          evidence: indicator.evidence,
          relevantNotes: [],
          suggestedActions: [
            'Acknowledge and celebrate this progress',
            'Explore what contributed to this improvement',
            'Consider how to maintain this positive trend'
          ],
          confidence: indicator.confidence,
          generatedAt: new Date(),
        });
      } else if (indicator.trend === 'declining' && indicator.confidence > 0.6) {
        insights.push({
          type: 'alert',
          priority: 'high',
          title: `Concerning Trend: ${indicator.metric}`,
          description: `A decline has been observed in ${indicator.metric}. This may warrant immediate attention.`,
          evidence: indicator.evidence,
          relevantNotes: [],
          suggestedActions: [
            'Explore recent changes that might have contributed',
            'Reassess current therapeutic approach',
            'Consider adjusting intervention strategies'
          ],
          confidence: indicator.confidence,
          generatedAt: new Date(),
        });
      }
    }

    return insights;
  }

  private async generateGoalAlignmentInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    const goals = graph.entities.filter(e => e.type === 'goal');
    const recentEntities = graph.entities.filter(e => 
      new Date(e.metadata.sessionDate).getTime() > Date.now() - (30 * 24 * 60 * 60 * 1000) // Last 30 days
    );

    // Check if recent sessions align with stated goals
    for (const goal of goals) {
      const alignedEntities = recentEntities.filter(entity =>
        this.areConceptuallyRelated(goal.name, entity.name)
      );

      if (alignedEntities.length === 0) {
        insights.push({
          type: 'suggestion',
          priority: 'medium',
          title: `Goal Alignment: "${goal.name}"`,
          description: `Recent sessions haven't directly addressed this stated goal. Consider revisiting or updating therapeutic priorities.`,
          evidence: [`Goal stated: ${goal.metadata.firstSeen}`, 'No recent progress on this goal'],
          relevantNotes: [],
          suggestedActions: [
            'Check if this goal is still relevant to the client',
            'Develop specific steps toward this goal',
            'Discuss barriers to progress on this goal'
          ],
          confidence: 0.6,
          generatedAt: new Date(),
        });
      }
    }

    return insights;
  }

  private async generateInterventionInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    const interventions = graph.entities.filter(e => e.type === 'intervention');

    // Find highly effective interventions that could be expanded
    const effectiveInterventions = interventions.filter(i => i.metadata.effectiveness > 0.8);
    
    for (const intervention of effectiveInterventions) {
      insights.push({
        type: 'suggestion',
        priority: 'low',
        title: `Effective Intervention: ${intervention.name}`,
        description: `This intervention has shown high effectiveness (${Math.round(intervention.metadata.effectiveness * 100)}%). Consider expanding or adapting it for other challenges.`,
        evidence: [`Effectiveness score: ${intervention.metadata.effectiveness}`, 'Positive client response noted'],
        relevantNotes: [],
        suggestedActions: [
          'Explore how to apply this approach to other areas',
          'Deepen this intervention technique',
          'Teach client to self-apply this strategy'
        ],
        confidence: 0.8,
        generatedAt: new Date(),
      });
    }

    // Find interventions with low effectiveness
    const ineffectiveInterventions = interventions.filter(i => i.metadata.effectiveness < 0.4);
    
    for (const intervention of ineffectiveInterventions) {
      insights.push({
        type: 'alert',
        priority: 'medium',
        title: `Ineffective Intervention: ${intervention.name}`,
        description: `This intervention has shown limited effectiveness. Consider alternative approaches or modifications.`,
        evidence: [`Effectiveness score: ${intervention.metadata.effectiveness}`, 'Limited client progress with this approach'],
        relevantNotes: [],
        suggestedActions: [
          'Explore alternative intervention strategies',
          'Discuss with client what aspects aren\'t working',
          'Consider adapting the approach to better fit client needs'
        ],
        confidence: 0.7,
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  private async generateRiskInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    // Look for risk indicators in entities and connections
    const riskEntities = graph.entities.filter(e =>
      e.name.toLowerCase().includes('risk') ||
      e.name.toLowerCase().includes('harmful') ||
      e.name.toLowerCase().includes('dangerous') ||
      (e.metadata.sentiment === 'negative' && e.metadata.intensity > 0.8)
    );

    for (const riskEntity of riskEntities) {
      insights.push({
        type: 'alert',
        priority: 'urgent',
        title: `Risk Factor Identified: ${riskEntity.name}`,
        description: `A potential risk factor has been identified. Immediate assessment and safety planning may be necessary.`,
        evidence: [`Risk pattern detected: ${riskEntity.name}`, `Intensity: ${riskEntity.metadata.intensity || 'high'}`],
        relevantNotes: [],
        suggestedActions: [
          'Conduct immediate risk assessment',
          'Develop or update safety plan',
          'Consider increased session frequency',
          'Consult supervision or refer if necessary'
        ],
        confidence: 0.9,
        generatedAt: new Date(),
      });
    }

    return insights;
  }

  private async generateOpportunityInsights(graph: any): Promise<ProactiveInsight[]> {
    const insights: ProactiveInsight[] = [];

    // Look for connections that suggest therapeutic opportunities
    const strongConnections = graph.connections.filter(c => c.strength > 0.8);

    for (const connection of strongConnections) {
      const fromEntity = graph.entities.find(e => e.id === connection.fromEntityId);
      const toEntity = graph.entities.find(e => e.id === connection.toEntityId);

      if (fromEntity && toEntity && connection.relationshipType === 'leads_to') {
        insights.push({
          type: 'suggestion',
          priority: 'medium',
          title: `Therapeutic Opportunity: ${fromEntity.name} â†’ ${toEntity.name}`,
          description: `A strong pattern has been identified where "${fromEntity.name}" consistently leads to "${toEntity.name}". This could be leveraged therapeutically.`,
          evidence: connection.evidence,
          relevantNotes: [],
          suggestedActions: [
            'Explore this pattern with the client',
            'Use this insight for intervention planning',
            'Help client recognize this connection'
          ],
          confidence: connection.strength,
          generatedAt: new Date(),
        });
      }
    }

    return insights;
  }

  private async findRelevantHistory(
    clientId: string,
    practitionerId: string,
    context?: any
  ): Promise<Array<{
    noteId: string;
    content: string;
    relevanceScore: number;
    reason: string;
  }>> {
    // Use semantic search to find historically relevant notes
    const searchService = new ClinicalSemanticSearch();
    
    const queries = [];
    if (context?.plannedTopics) {
      queries.push(...context.plannedTopics);
    }
    if (context?.lastSessionSummary) {
      queries.push(context.lastSessionSummary);
    }
    
    if (queries.length === 0) {
      queries.push('progress therapy goals emotional patterns'); // Default broad query
    }

    const relevantHistory = [];
    
    for (const query of queries) {
      const results = await searchService.searchClientHistory(
        clientId,
        practitionerId,
        query,
        { limit: 5, similarityThreshold: 0.6 }
      );

      for (const result of results.results) {
        relevantHistory.push({
          noteId: result.noteId,
          content: result.relevantExcerpt,
          relevanceScore: result.similarity,
          reason: `Semantically related to: "${query.substring(0, 50)}..."`
        });
      }
    }

    // Remove duplicates and sort by relevance
    const uniqueHistory = relevantHistory.filter((item, index, self) =>
      index === self.findIndex(other => other.noteId === item.noteId)
    ).sort((a, b) => b.relevanceScore - a.relevanceScore);

    return uniqueHistory.slice(0, 10); // Top 10 most relevant
  }

  private async generateSuggestedQuestions(graph: any, context?: any): Promise<string[]> {
    const questions: string[] = [];

    // Generate questions based on recent patterns
    const recentThemes = graph.entities.filter(e => 
      e.type === 'theme' && 
      new Date(e.metadata.sessionDate).getTime() > Date.now() - (14 * 24 * 60 * 60 * 1000) // Last 2 weeks
    );

    for (const theme of recentThemes.slice(0, 3)) {
      questions.push(`How has your experience with ${theme.name} been since our last session?`);
    }

    // Generate questions based on goals
    const goals = graph.entities.filter(e => e.type === 'goal').slice(0, 2);
    for (const goal of goals) {
      questions.push(`What progress have you made toward "${goal.name}"?`);
    }

    // Generate questions based on effective interventions
    const effectiveInterventions = graph.entities.filter(e => 
      e.type === 'intervention' && e.metadata.effectiveness > 0.7
    ).slice(0, 2);

    for (const intervention of effectiveInterventions) {
      questions.push(`Have you been able to practice ${intervention.name} since our last session?`);
    }

    return questions;
  }

  private async identifyTherapeuticOpportunities(graph: any): Promise<string[]> {
    const opportunities: string[] = [];

    // Look for connections that suggest intervention opportunities
    const causalConnections = graph.connections.filter(c => 
      c.relationshipType === 'leads_to' && c.strength > 0.7
    );

    for (const connection of causalConnections) {
      const fromEntity = graph.entities.find(e => e.id === connection.fromEntityId);
      const toEntity = graph.entities.find(e => e.id === connection.toEntityId);

      if (fromEntity && toEntity) {
        if (fromEntity.metadata.sentiment === 'negative' && toEntity.metadata.sentiment === 'positive') {
          opportunities.push(`Transform "${fromEntity.name}" into a pathway to "${toEntity.name}"`);
        }
        
        if (fromEntity.metadata.category === 'maladaptive' && toEntity.metadata.category === 'adaptive') {
          opportunities.push(`Use "${fromEntity.name}" as a trigger to practice "${toEntity.name}"`);
        }
      }
    }

    // Look for successful patterns that could be generalized
    const successfulPatterns = graph.entities.filter(e => 
      e.metadata.sentiment === 'positive' && e.metadata.frequency > 2
    );

    for (const pattern of successfulPatterns) {
      opportunities.push(`Generalize the success of "${pattern.name}" to other life areas`);
    }

    return opportunities.slice(0, 5); // Top 5 opportunities
  }

  private areConceptuallyRelated(concept1: string, concept2: string): boolean {
    // Simplified conceptual relatedness - in production, use semantic similarity
    const words1 = concept1.toLowerCase().split(/\s+/);
    const words2 = concept2.toLowerCase().split(/\s+/);
    
    return words1.some(word => words2.includes(word)) || 
           words2.some(word => words1.includes(word));
  }
}

// =============================================================================
// 3. CONTEXTUAL MEMORY SYSTEM
// File: src/services/contextualMemory.ts
// =============================================================================

export interface ContextualMemory {
  id: string;
  clientId: string;
  context: 'session_opening' | 'goal_discussion' | 'intervention_planning' | 'progress_review' | 'crisis_moment';
  relevantEntities: string[];
  historicalContext: string[];
  suggestedContent: string[];
  confidence: number;
  lastUpdated: Date;
}

/**
 * Contextual Memory System
 * Provides the right information at the right time based on therapeutic context
 */
export class ContextualMemorySystem {
  private insightEngine: ProactiveInsightEngine;
  private knowledgeGraph: ClinicalKnowledgeGraph;

  constructor() {
    this.insightEngine = new ProactiveInsightEngine();
    this.knowledgeGraph = new ClinicalKnowledgeGraph();
  }

  /**
   * Get contextually relevant information for the current therapeutic moment
   */
  async getContextualMemory(
    clientId: string,
    practitionerId: string,
    context: {
      currentActivity: 'session_opening' | 'goal_discussion' | 'intervention_planning' | 'progress_review' | 'crisis_moment';
      currentTopics?: string[];
      clientCurrentState?: string;
      sessionObjectives?: string[];
    }
  ): Promise<{
    relevantMemories: Array<{
      content: string;
      relevanceScore: number;
      type: 'historical_pattern' | 'previous_success' | 'warning_sign' | 'therapeutic_opportunity';
      context: string;
    }>;
    suggestedActions: string[];
    contextualInsights: ProactiveInsight[];
  }> {
    // 1. Get relevant insights for current context
    const insights = await this.insightEngine.generateInsightsForSession(
      clientId,
      practitionerId,
      {
        plannedTopics: context.currentTopics,
        lastSessionSummary: context.clientCurrentState,
      }
    );

    // 2. Build contextual memory based on current activity
    const relevantMemories = await this.buildContextualMemories(
      clientId,
      practitionerId,
      context
    );

    // 3. Generate context-specific suggested actions
    const suggestedActions = await this.generateContextualActions(
      context,
      insights.insights,
      relevantMemories
    );

    return {
      relevantMemories,
      suggestedActions,
      contextualInsights: insights.insights,
    };
  }

  private async buildContextualMemories(
    clientId: string,
    practitionerId: string,
    context: any
  ): Promise<Array<{
    content: string;
    relevanceScore: number;
    type: 'historical_pattern' | 'previous_success' | 'warning_sign' | 'therapeutic_opportunity';
    context: string;
  }>> {
    const memories = [];
    const searchService = new ClinicalSemanticSearch();

    switch (context.currentActivity) {
      case 'session_opening':
        // Provide overview of recent patterns and what to check in on
        const recentPatterns = await searchService.searchClientHistory(
          clientId,
          practitionerId,
          'recent feelings mood progress challenges',
          { limit: 3 }
        );

        for (const result of recentPatterns.results) {
          memories.push({
            content: result.relevantExcerpt,
            relevanceScore: result.similarity,
            type: 'historical_pattern' as const,
            context: 'Check in on recent emotional patterns from previous sessions',
          });
        }
        break;

      case 'goal_discussion':
        // Surface previous goal-setting conversations and outcomes
        const goalHistory = await searchService.searchClientHistory(
          clientId,
          practitionerId,
          'goals objectives targets want to achieve progress',
          { limit: 5 }
        );

        for (const result of goalHistory.results) {
          memories.push({
            content: result.relevantExcerpt,
            relevanceScore: result.similarity,
            type: 'therapeutic_opportunity' as const,
            context: 'Previous goal-setting discussions and outcomes',
          });
        }
        break;

      case 'intervention_planning':
        // Show what interventions worked/didn't work before
        const interventionHistory = await searchService.searchClientHistory(
          clientId,
          practitionerId,
          'techniques strategies homework helpful effective worked',
          { limit: 4 }
        );

        for (const result of interventionHistory.results) {
          memories.push({
            content: result.relevantExcerpt,
            relevanceScore: result.similarity,
            type: 'previous_success' as const,
            context: 'Previous intervention outcomes and client responses',
          });
        }
        break;

      case 'progress_review':
        // Show historical progress patterns and milestones
        const progressHistory = await searchService.searchClientHistory(
          clientId,
          practitionerId,
          'progress improvement better worse milestone breakthrough',
          { limit: 5 }
        );

        for (const result of progressHistory.results) {
          memories.push({
            content: result.relevantExcerpt,
            relevanceScore: result.similarity,
            type: 'historical_pattern' as const,
            context: 'Historical progress patterns and significant milestones',
          });
        }
        break;

      case 'crisis_moment':
        // Show previous crisis responses and what helped
        const crisisHistory = await searchService.searchClientHistory(
          clientId,
          practitionerId,
          'crisis difficult hard struggle support helped coping',
          { limit: 3 }
        );

        for (const result of crisisHistory.results) {
          memories.push({
            content: result.relevantExcerpt,
            relevanceScore: result.similarity,
            type: 'warning_sign' as const,
            context: 'Previous crisis moments and effective support strategies',
          });
        }
        break;
    }

    return memories.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  private async generateContextualActions(
    context: any,
    insights: ProactiveInsight[],
    memories: any[]
  ): Promise<string[]> {
    const actions: string[] = [];

    switch (context.currentActivity) {
      case 'session_opening':
        actions.push('Check in on mood and energy level since last session');
        actions.push('Review any homework or practices from previous session');
        
        const recentConcerns = insights.filter(i => i.priority === 'high' || i.priority === 'urgent');
        if (recentConcerns.length > 0) {
          actions.push('Address urgent concerns identified in recent patterns');
        }
        break;

      case 'goal_discussion':
        actions.push('Review progress on existing goals');
        actions.push('Explore any shifts in priorities or values');
        
        const goalAlignmentIssues = insights.filter(i => i.title.includes('Goal Alignment'));
        if (goalAlignmentIssues.length > 0) {
          actions.push('Reassess goal relevance and modify as needed');
        }
        break;

      case 'intervention_planning':
        const effectiveInterventions = insights.filter(i => i.title.includes('Effective Intervention'));
        if (effectiveInterventions.length > 0) {
          actions.push('Build on previously effective intervention strategies');
        }
        
        const ineffectiveInterventions = insights.filter(i => i.title.includes('Ineffective Intervention'));
        if (ineffectiveInterventions.length > 0) {
          actions.push('Modify or replace interventions that haven\'t been effective');
        }
        
        actions.push('Collaborate with client on intervention preferences');
        break;

      case 'progress_review':
        actions.push('Celebrate specific improvements and milestones');
        actions.push('Identify patterns in what contributes to progress');
        
        const progressConcerns = insights.filter(i => i.title.includes('Concerning Trend'));
        if (progressConcerns.length > 0) {
          actions.push('Address concerning trends that may need intervention');
        }
        break;

      case 'crisis_moment':
        actions.push('Ensure immediate safety and stabilization');
        actions.push('Use previously effective coping strategies');
        actions.push('Activate support systems that have helped before');
        
        const riskInsights = insights.filter(i => i.type === 'alert');
        if (riskInsights.length > 0) {
          actions.push('Implement crisis intervention protocols');
        }
        break;
    }

    return actions;
  }
}

// =============================================================================
// 4. INTEGRATION WITH UI COMPONENTS
// File: src/components/SecondBrainInterface.tsx (React Component Example)
// =============================================================================

/*
This would be integrated into your React components to provide the "second brain" UI

import React, { useState, useEffect } from 'react';
import { ProactiveInsightEngine, ContextualMemorySystem } from '../services/insightEngine';

export const SecondBrainInterface: React.FC<{
  clientId: string;
  practitionerId: string;
  currentContext: 'session_opening' | 'goal_discussion' | 'intervention_planning' | 'progress_review';
}> = ({ clientId, practitionerId, currentContext }) => {
  const [insights, setInsights] = useState([]);
  const [memories, setMemories] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadSecondBrainData = async () => {
      const memorySystem = new ContextualMemorySystem();
      const data = await memorySystem.getContextualMemory(
        clientId,
        practitionerId,
        { currentActivity: currentContext }
      );
      
      setInsights(data.contextualInsights);
      setMemories(data.relevantMemories);
      setLoading(false);
    };

    loadSecondBrainData();
  }, [clientId, currentContext]);

  if (loading) return <div>Loading clinical insights...</div>;

  return (
    <div className="second-brain-interface">
      <div className="insights-panel">
        <h3>Proactive Insights</h3>
        {insights.map(insight => (
          <div key={insight.id} className={`insight priority-${insight.priority}`}>
            <h4>{insight.title}</h4>
            <p>{insight.description}</p>
            <div className="suggested-actions">
              {insight.suggestedActions.map(action => (
                <span key={action} className="action-chip">{action}</span>
              ))}
            </div>
          </div>
        ))}
      </div>

      <div className="memory-panel">
        <h3>Relevant History</h3>
        {memories.map(memory => (
          <div key={memory.id} className={`memory type-${memory.type}`}>
            <div className="memory-content">{memory.content}</div>
            <div className="memory-context">{memory.context}</div>
          </div>
        ))}
      </div>
    </div>
  );
};
*/

// =============================================================================
// IMPLEMENTATION SUMMARY
// =============================================================================

/*
ðŸ§  SECOND BRAIN CORE FUNCTIONALITY IMPLEMENTATION:

âœ… 1. KNOWLEDGE GRAPH BUILDER
   - Extracts entities (themes, goals, interventions, emotions, behaviors)
   - Discovers semantic, temporal, and causal connections
   - Builds comprehensive therapeutic journey map
   - Identifies contradictory patterns and opportunities

âœ… 2. PROACTIVE INSIGHT ENGINE
   - Generates insights without being asked
   - Pattern recognition and trend analysis
   - Goal alignment monitoring
   - Intervention effectiveness tracking
   - Risk detection and opportunity identification

âœ… 3. CONTEXTUAL MEMORY SYSTEM
   - Provides right information at right time
   - Context-aware suggestions based on therapeutic moment
   - Historical pattern surfacing
   - Crisis-responsive memory activation

âœ… 4. INTELLIGENT RECALL FEATURES
   - Semantic connections across all sessions
   - Temporal pattern recognition
   - Therapeutic journey mapping
   - Cross-client pattern analysis (privacy-preserved)
   - Proactive suggestion generation

ðŸš€ DEPLOYMENT STEPS:
1. Implement knowledge graph extraction pipeline
2. Set up proactive insight generation
3. Integrate contextual memory into UI
4. Train pattern recognition models
5. Add real-time insight delivery

This creates a true "second brain" that:
- Remembers everything across all sessions
- Makes intelligent connections you might miss
- Surfaces relevant information proactively
- Tracks therapeutic progress automatically
- Suggests interventions based on what worked before
- Alerts to concerning patterns or opportunities

The system becomes smarter the more you use it, building an increasingly sophisticated understanding of each client's unique therapeutic journey.
*/